<?php

/**
 * Handles all routing pattern setup within the Silverstripe routing tables
 * 
 * @package datelink
 * @author Damian Mooyman
 */
class DateLinkRouter extends Object implements IDateLinkRouter
{

    protected function getCacheFilePath()
    {
        return ASSETS_PATH . '/' . DateLink::config()->route_cache;
    }

    /**
     * Registers all cached routes with silverstripe 
     */
    public function RegisterRoutes()
    {
        $cachePath = $this->getCacheFilePath();
        if (!file_exists($cachePath)) {
            return Debug::message('DateLink route cache file could not be found. This can be generated by using /dev/build');
        }

        $document = new DOMDocument();
        $document->load($cachePath);

        foreach ($document->getElementsByTagName('route') as $route) {
            $link = $route->getElementsByTagName('link')->item(0)->nodeValue;
            $parentID = $route->getElementsByTagName('page_id')->item(0)->nodeValue;
            $years = $route->getElementsByTagName('year');
            foreach ($years as $year) {
                $this->registerRoute($link, $parentID, $year->nodeValue);
            }
        }
    }

    /**
     * Registers a single routing rule within silverstripe
     * @param string $parentLink The link of the parent page
     * @param integer $parentID The ID of the parent page
     * @param integer $yearNumber The value of the $Year parameter
     */
    protected function registerRoute($parentLink, $parentID, $yearNumber)
    {
        $parentLink = trim($parentLink, '/');
        $pattern = DateLink::config()->url_pattern;

        // Replace wildcards in pattern
        // Substitute leading-zero indicators
        $pattern = preg_replace('/#\$/', '$', $pattern);
        // substitute the year
        $pattern = preg_replace('/\$Year!?/i', $yearNumber, $pattern);
        // substitute parent url
        $pattern = preg_replace('/\$ParentLink!?/i', $parentLink, $pattern);
        // Fix any extra slashes, which may occur if the $parentLink is /
        $pattern = trim($pattern, '/');

        // Registers a route with silverstripe
        $routes = array($pattern => array(
            'Controller' => DateLink::config()->controller,
            'ParentID' => $parentID, // Used as a shortcut for simplifying nested routing
            'Year' => $yearNumber
        ));
        
        Config::inst()->update('Director', 'rules', $routes);
    }

    /**
     * Determines the distinct years in the set of all pages given
     * 
     * @param SS_List $pages
     */
    protected function determineYears($pages)
    {
        $years = array();
        if ($pages) {
            foreach ($pages as $page) {
                $date = $page->getRouteDate();
                if (empty($date)) {
                    continue;
                }
                $parsedDate = date_parse($date);
                $years[] = $parsedDate['year'];
            }
        }
        return array_unique($years);
    }

    /**
     * Instructs the module to refresh the routing XML cache file
     * This may not be called during manifest initialisation (_config.php) as database access is not available
     */
    public function RefreshCache()
    {
        // Builds XML cache file using all available routes
        $document = new DOMDocument();
        $document->formatOutput = true;
        $routes = $document->createElement('routes');
        $document->appendChild($routes);

        // append all routes
        $holderClasses = DateLink::config()->holder_classes;
        foreach ($holderClasses as $className) {
            foreach (DataObject::get($className) as $holderPage) {
                $route = $document->createElement('route');
                $link = $document->createElement('link', $holderPage->RelativeLink());
                $route->appendChild($link);
                $id = $document->createElement('page_id', $holderPage->ID);
                $route->appendChild($id);

                // Run through children and pull out all distinct year fields
                // We must use years in our URLS to distinguish all routes from non-numeric routes such as
                // page actions. It's not necessary to consider months, as by then the route will be sufficiently
                // distinguished.
                $children = $holderPage->AllChildren();
                $yearList = $this->determineYears($children);
                $years = $document->createElement('years');
                foreach ($yearList as $yearNumber) {
                    $year = $document->createElement('year', $yearNumber);
                    $years->appendChild($year);
                }
                $route->appendChild($years);
                $routes->appendChild($route);
            }
        }

        // Ensure output directory exists
        $outputPath = $this->getCacheFilePath();

        Filesystem::makeFolder(dirname($outputPath));
        $document->save($outputPath);
    }
}
